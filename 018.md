chaduke

medium

# Wrong check condition for setLimit() because it fails to recognize the real effective ohm minting limit is ohmLimit +  circulatingOhmBurned!

## Summary
Wrong check condition for setLimit(). This is because setLimit() fails to consider the effect of ``circulatingOhmBurned``, which is considered by ``mintOhmToVault()`` when minting Ohm. The effective limit is not ``ohmLimit`` but ``ohmLimit +  circulatingOhmBurned``. 

## Vulnerability Detail
First, let's look at the function ``mintOhmToVault``, the amount of Ohm that can be minted as constrained by the following condition, inferred from L241.

[https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L239-L249](https://github.com/sherlock-audit/2023-03-olympus/blob/main/sherlock-olympus/src/policies/BoostedLiquidity/BLVaultManagerLido.sol#L239-L249)

```javascript
deployedOhm + amount_ <= ohmLimit + circulatingOhmBurned
```

As a result, we have 
```javascript
deployeeOhm <= ohmLimit + circulatingOhmBurned
```

In other words, the real minting limit is ``ohmLimit + circulatingOhmBurned``, not ``ohmLimit``!

However, the following condition for ``setLimit()`` is not consistent with the above condition:

```javascript
function setLimit(uint256 newLimit_) external override onlyRole("liquidityvault_admin") {
        if (newLimit_ < deployedOhm) revert BLManagerLido_InvalidLimit();
        ohmLimit = newLimit_;
    }
```
It fails to consider the effect of ``circulatingOhmBurned``. The effective limit is not ``ohmLimit`` but ``ohmLimit +  circulatingOhmBurned``.  The correction should be:

```diff
function setLimit(uint256 newLimit_) external override onlyRole("liquidityvault_admin") {
-        if (newLimit_ < deployedOhm) revert BLManagerLido_InvalidLimit();
+       if (newLimit_+ circulatingOhmBurned < deployedOhm) revert BLManagerLido_InvalidLimit();
        ohmLimit = newLimit_;
    }
```

For example, suppose oldLimit = 1,000,000e18 and circulatingOhmBurned = 500,000e18 and deployedOhm = 1,400,000e18. Since ``deployedOhm < oldLimit + circulatingOhmBurned``, there is no violation. 

Now suppose want to set newLimit = 950,000e18, since we still have ``deployedOhm < newLimit + circulatingOhmBurned``, there is no violation either. 

Using the current implementation, however, the function ``setLimit()`` will reject this change to the newLimit, even though there is no violation.


## Impact
setLimit() fails to consider the real/effective limit is ``newLimit_+circulatingOhmBurned``, not just ``newLimit``.  As a result, ``setLimit()`` might fail even when it is not supposed to. As a result, one need to set the limit unnecessary high!


## Code Snippet
See above

## Tool used
VScode


Manual Review

## Recommendation
Correction, the effective limit is ``newLimit+circulatingOhmBurned``:

```diff
function setLimit(uint256 newLimit_) external override onlyRole("liquidityvault_admin") {
-        if (newLimit_ < deployedOhm) revert BLManagerLido_InvalidLimit();
+       if (newLimit_+ circulatingOhmBurned < deployedOhm) revert BLManagerLido_InvalidLimit();
        ohmLimit = newLimit_;
    }
```